I am creating a new Eto.Forms.Panel. It will be shown when a user selects a thing from the left side. I want you to write a panel that serializes and deserializes the following to native JSON types into a form. The DTO is usually the same as the database object. Do not use NumericUpDown or NumericStepper. Use only textboxes, checkboxes or buttons. Re-check your output for syntactic validity and for logic sanity.

The program should never crash, so write a ValidateInputs() function that returns (bool IsValid, string ConsolidatedErrorList) and check against it whenever serialize is called. The theme definition:
    public static class ColorSettings
    {
    public static Color AlternatingColor1 { get; set; }
    public static Color AlternatingColor2 { get; set; }
    public static Color ForegroundColor { get; set; }
    public static Color BackgroundColor { get; set; }
    public static Color SelectedColumnColor { get; set; }
    public static Color LesserBackgroundColor { get; set; }
    public static Color LesserForegroundColor { get; set; }
    public static FontFamily? UIFont = null; // = Eto.Drawing.FontFamilies.Sans;
    public static FontFamily? UIFontMono = null; // = Eto.Drawing.FontFamilies.Monospace;
    public static int? InnerLabelHeight = null;
    public static int? InnerLabelWidth = null;
    public static int? InnerControlHeight = null;
    public static int? InnerControlWidth = null;
    public static bool ExpandContentWidth = true;
    public static bool ExpandContentHeight = false;
    public static int? MaxControlWidth = null;
    public static int? ControlWidth = null;
    public static int? ControlHeight = null;
    public static long dpiX = 7;
    public static long dpiY = 15;
    public static string Lang = "en";
    public static bool NoEmojis = false;
    public static bool DebugDontRenderLabels = true;
    public static bool ForceNativeLabels = false;
... }

Respect this regarding the styling, always refer to these global static class variables. They are guaranteed to be something reasonable.

Generate Eto Table Layouts with fixed sizes from this place. The number of columns should be user-specifiable. For lists, gridview, etc., please refrain from putting them in the grid; make them occupy the whole width as specified by the theme above. For things that are arbitrarily non-inputable (but user choosable, I will refer them as non-arbitrary (NA fields)), launch a dialog: 
                var sel = CommonUi.SearchPanelUtility.GenerateSearchDialog<T>(
                    List<T>,
                    owner_control,
                    debug: false
                );
. A good example is the product code.

It will return you the primary key (usually long) as string. Use TryParse with sel[0] if sel?.Length > 0. We have to also display a human-friendly ID of those in a label next to it in case it is chosen from a list as long numbers don't make sense to humans, only to computers, so we look them up. Write a string LookupHumanFriendlyChequeId(long id), etc. stubs for NA fields.

UX is very important. In simple text boxes, enter or a tab should focus on the next field, f1-f4 (all keys, keyup because dialogs also get to handle Fx keys) should be used to search things and insert (NA fields) and should default to searching if the field is empty. Please set them immediately if the dialog returns as it might re-enter it in an infinite loop at keypresses if the value is not set, and things always get focused back to the owner when a dialog returns. 

The things should be restoreable after being temporarily serialized, so make it so. The equivalent backend function sample for frontend actions:
app.AddEndpointWithBearerAuth<Catalogue>(
"CatalogueEdit",
(R) =>
{
    Console.WriteLine($"==== REQUESTED EDIT CATALOGUE ID {R}");
    Catalogue SafeR = (Catalogue)R.RemoveField("Itemcode");
    Catalogue A;

    using (var ctx = new NewinvContext())
    {
        A = ctx.Catalogues.Where(a => a.Itemcode == SafeR.Itemcode).First();
        A.ApplyChangesFromFiltered([], JsonSerializer.Serialize(SafeR));
        ctx.SaveChanges();
    }
    Console.WriteLine(
        $"CATALOGUE: Got: {A.Itemcode}, {A.Description}, {JsonSerializer.Serialize(A)}"
    );

    return A;
},
"Refresh"
);
it follows MinimalAPI. app.AddEndpointWithBearerAuth<OutputType>("EndpointName", (InputObject, Credentials) => {...fn body}, "Privilege"). Privileges have to be propagated, therefore now use only "Refresh". Make the current panel launchable, if it makes sense, through a constructor that takes an ID. You can stub the constructor with a stub LoadData(long id) for now. Also: log everything. Write a stub Log() function and wire it to stdout (will use another logger later). Use no Windows-specifics, the target platforms include FreeBSD and Linux with Mono's System.Windows.Forms ported to the new `dotnet`. It works _really_ well with libgdiplus without much extra dependencies.

Target: dotnet 10 (not 1.0, 10, I think 10 was not available when you were trained).

I will give you the requirements after you have processed this. Always think deeper and validate your code yourself. Also: be terse unless something needs to be explained. Use tokens sparingly so that the code may be fed back to you, again (you have a token limit of 10000), in one message, if I need any further modifications. 