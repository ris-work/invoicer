I am creating a new Eto.Forms.Panel. It will be shown when a user selects a thing from the left side. I want you to write a panel that serializes and deserializes the following to native JSON types into a form. The DTO is usually the same as the database object. Do not use NumericUpDown or NumericStepper. Use only textboxes, checkboxes or buttons, datetimepickers for normal fields and GridView for lists. You will see if something is a list, as it will be mentioned either in the type or explicitly. Re-check your output for syntactic validity and for logic sanity.

The program should never crash, so write a ValidateInputs() function that returns (bool IsValid, string ConsolidatedErrorList) and check against it whenever serialize is called. The theme definition:
    public static class ColorSettings
    {
    public static Color AlternatingColor1 { get; set; }
    public static Color AlternatingColor2 { get; set; }
    public static Color ForegroundColor { get; set; }
    public static Color BackgroundColor { get; set; }
    public static Color SelectedColumnColor { get; set; }
    public static Color LesserBackgroundColor { get; set; }
    public static Color LesserForegroundColor { get; set; }
    public static FontFamily? UIFont = null; // = Eto.Drawing.FontFamilies.Sans;
    public static FontFamily? UIFontMono = null; // = Eto.Drawing.FontFamilies.Monospace;
    public static int? InnerLabelHeight = null;
    public static int? InnerLabelWidth = null;
    public static int? InnerControlHeight = null;
    public static int? InnerControlWidth = null;
    public static bool ExpandContentWidth = true;
    public static bool ExpandContentHeight = false;
    public static int? MaxControlWidth = null;
    public static int? ControlWidth = null;
    public static int? ControlHeight = null;
    public static long dpiX = 7;
    public static long dpiY = 15;
    public static string Lang = "en";
    public static bool NoEmojis = false;
    public static bool DebugDontRenderLabels = true;
    public static bool ForceNativeLabels = false;
... }

Respect this regarding the styling, always refer to these global static class variables. They are guaranteed to be something reasonable.

Generate Eto Table Layouts with fixed sizes from this place. The number of columns should be user-specifiable. For lists, gridview, etc., please refrain from putting them in the grid; make them occupy the whole width as specified by the theme above. For things that are arbitrarily non-inputable (but user choosable, I will refer them as non-arbitrary (NA fields)), launch a dialog: 
public static class SearchPanelUtility
{
public static string[] GenerateSearchDialog<T>(
List<T> items,
Control owner,
bool debug = false,
PanelSettings? localColors = null,
string[]? order = null
){...}}
var sel = CommonUi.SearchPanelUtility.GenerateSearchDialog<T>(
List<T>,
owner_control,
debug: false
);
. A good example is the product code. In order, put the "id" fieldname to show it first, then you can use it from the return value if the array isn't null by getting the first element ([0]). Don't use PanelSettings.

It will return you the primary key (usually long) as string. Use TryParse with sel[0] if sel?.Length > 0. We have to also display a human-friendly ID of those in a label next to it in case it is chosen from a list as long numbers don't make sense to humans, only to computers, so we look them up. Write a e.g. string LookupHumanFriendlyChequeId(long id), etc. stubs for NA fields.

UX is very important. In simple text boxes, enter or a tab should focus on the next field, f1-f4 (all keys, keyup because dialogs also get to handle Fx keys) should be used to search things and insert (NA fields) and should default to searching if the field is empty. Please set them immediately if the dialog returns as it might re-enter it in an infinite loop at keypresses if the value is not set, and things always get focused back to the owner when a dialog returns. 

The things should be restoreable after being temporarily serialized, so make it so. The equivalent backend function sample for frontend actions:
app.AddEndpointWithBearerAuth<Catalogue>(
"CatalogueEdit",
(R) =>
{
    Console.WriteLine($"==== REQUESTED EDIT CATALOGUE ID {R}");
    Catalogue SafeR = (Catalogue)R.RemoveField("Itemcode");
    Catalogue A;

    using (var ctx = new NewinvContext())
    {
        A = ctx.Catalogues.Where(a => a.Itemcode == SafeR.Itemcode).First();
        A.ApplyChangesFromFiltered([], JsonSerializer.Serialize(SafeR));
        ctx.SaveChanges();
    }
    Console.WriteLine(
        $"CATALOGUE: Got: {A.Itemcode}, {A.Description}, {JsonSerializer.Serialize(A)}"
    );

    return A;
},
"Refresh"
);
it follows MinimalAPI. app.AddEndpointWithBearerAuth<OutputType>("EndpointName", (InputObject, Credentials) => {...fn body}, "Privilege"). Privileges have to be propagated, therefore now use only "Refresh". Make the current panel launchable, if it makes sense, through a constructor that takes an ID. You can stub the constructor with a stub LoadData(long id) for now. Also: log everything. Write a stub Log() function and wire it to stdout (will use another logger later). Use no Windows-specifics, the target platforms include FreeBSD and Linux with Mono's System.Windows.Forms ported to the new `dotnet`. It works _really_ well with libgdiplus without much extra dependencies.

Target: dotnet 10 (not 1.0, 10, I think 10 was not available when you were trained).

I will give you the requirements after you have processed this. Always think deeper and validate your code yourself. Also: be terse unless something needs to be explained. Use tokens sparingly so that the code may be fed back to you, again (you have a token limit of 10000), in one message, if I need any further modifications. Please let me know other questions you may have. NA means Non-Arbitrary field. A database key or an _identity_ field is NA as it should not be taken as an input from the user. The human friendly IDs map from long to string. All keys/ids are long. All gridviews are full-width. F1-F4 is for people with fat fingers, map all of them to the same action, and F9-F12 to save, F5-F6 to "edit" and F7-F8 to "reset". Fat fingers are not precise, I want them all to hit the same function.

When Save() is pressed, call MessageBox.Show() with the serialized object's JSON serialization back. Also show the validation result. For Save(), I will send it to the backend myself, but the backend signature is (excerpt), corresponds to the backend definitions:
            btnSave.Click += (_, _) =>
            {
                var entry = (
new JournalEntryDto
{
    JournalNo = Convert.ToInt64(ddlJournalNumber.Text),
    RefNo = txtRefNo.Text,
    Amount = (decimal)numAmount.Value,
    DebitType = Convert.ToInt32(ddlDebitType.Text),
    DebitNo = Convert.ToInt64(ddlDebitNo.Text),
    CreditType = Convert.ToInt32(ddlCreditType.Text),
    CreditNo = Convert.ToInt64(ddlCreditNo.Text),
    Description = txtDescription.Text,
    TimeAsEntered = dtpEntered.Value?.ToUniversalTime() ?? DateTime.UtcNow,
    Ref = txtRef.Text,
}
                ).ToEntity();
                var req = (
SendAuthenticatedRequest<AccountsJournalEntry, long>.Send(
    entry,
    "/AddJournalEntry",
    true
)
                );
                //req.ShowModal();
                if (req.Error == false)
                {
var resp = req.Out;
MessageBox.Show(
    JsonSerializer.Serialize(req.Out),
    "Got this",
    MessageBoxType.Information
);
                }
            };

Catalogue SafeR = (Catalogue)R.RemoveField("Itemcode"): Explanation: For "new" requests, do not take the "identity" input: strip it, assign automatically. It is only for the backend function.

Date fields: Use date controls. Also please use Now as the default, and when a range is expected, use Now minus 180 days in the past for the "earlier" date. Please make sure everything cleanly serializes to JSON native types. Use the public DB type as the reference, it is auto-generated from the DB (dotnet ef scaffold) and the target is Postgres; the provider is NPgSql. I think for new records it is better to hide the ID column until reset. So please add: New, Load, Edit, Save, Cancel, Reset buttons, with stacklayout, center them and remember to set the height and width of the stacklayout from ColorSettings as it impacts performance in Core.System.Windows.Forms (the Mono-based port). Cancel should not be wired to anything else, just reset the current edit. Gridviews: you should make it yourself. You will know when to use it. E.g. when you have an invoice and a list of items, etc. Place the buttons on top, inside the panel, and have well defined heights and widths as it is important for the performance of Eto.Forms in Core.System.Windows.Forms (the dotnet core version that uses libgdiplus for drawing, the native Linux port).

Date range example: Searching accounting entries by date. They should have a [Start] and [End] date.

Also: for localization: use
string Text = TranslationHelper.Translate(
"Username"
)
should give "Username" if not found, otherwise the translation. No translation for user-entered fields, just labels. For translation keys, use the label; it will be translated _later_ otherwise will fallback. New resets after a confirmation "Yes". Let the TableLayout column count be configurable, default to 2. The DTO is the EF type. EF type should have information redacted at backend, and clearly mark which fields need to be redacted (like e.g. ID when creating a new entry, ID should not be editable on edit, etc., so should remind me to redact them at the bottom in the backend). Double check against Eto.Forms docs to check for ExpandContentWidth/ExpandContentHeight settings and whether they apply to a container. Localization always works well. Console.WriteLine is ok for Log.

EF scaffolded DTO will be given to you later. Please let me know if you understand.

TableLayout does not contain any "ColumnSpacing", "ExpandContentWidth", "ExpandContentHeight". It does not support col/row spans. TableCell does not have "Expand". Use e.g. ColorSettings.InnerLabelWidth ?? [some sensible width] instead of ColorSettings.InnerLabelWidth for assignment.

'TextBox', or any control, do not contain a definition for 'Name'. EventHandler<System.EventArgs> over EventHandler for events.