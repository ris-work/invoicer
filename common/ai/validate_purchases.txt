using System; using System.Collections.Generic; namespace RV.InvNew.Common; public partial class ReceivedInvoice { public long ReceivedInvoiceNo { get; set; } public bool IsPosted { get; set; } public long SupplierId { get; set; } public string SupplierName { get; set; } = null!; public string Remarks { get; set; } = null!; public string Reference { get; set; } = null!; public double GrossTotal { get; set; } public double TransportCharges { get; set; } public double Discount { get; set; } public double DefaultVatPercentage { get; set; } public long DefaultVatCategory { get; set; } public double DiscountPercentage { get; set; } public bool IsSettled { get; set; } } using System; using System.Collections.Generic; namespace RV.InvNew.Common; public partial class Purchase { public long ReceivedInvoiceId { get; set; } public long Itemcode { get; set; } public long PackSize { get; set; } public long PackQuantity { get; set; } public double ReceivedAsUnitQuantity { get; set; } public long FreePacks { get; set; } public double FreeUnits { get; set; } public DateTimeOffset ExpiryDate { get; set; } public DateTimeOffset? ManufacturingDate { get; set; } public string? ManufacturerBatchId { get; set; } public string ProductName { get; set; } = null!; public DateTimeOffset AddedDate { get; set; } public double DiscountPercentage { get; set; } public double DiscountAbsolute { get; set; } public double GrossProfitPercentage { get; set; } public double GrossProfitAbsolute { get; set; } public double CostPerUnit { get; set; } public double CostPerPack { get; set; } public double GrossCostPerUnit { get; set; } public double SellingPrice { get; set; } public double VatPercentage { get; set; } public long VatCategory { get; set; } public double VatAbsolute { get; set; } public string VatCategoryName { get; set; } = null!; public double TotalUnits { get; set; } } these are the two relevant types. Purchases refer to ReceivedInvoices (header). Please write validation function which validates each Purchase (use extension methods, namespace Rv.InvNew.Common) like Purchase1.ValidateDetailed(). It should return (bool ValidationStatus, string ErrorDescription)[] which describes whether each of the following conditions pass, and if not, what is the reason. Make it modular. Also write a Validate() function that aggregates from ValidateDetailed and returns (bool ValidationStatus, string ErrorDescription) which simply concatenates all error strings if present and returns false if at least one of the conditions fail. Now here is the thing: these are the validation rules. Make them as modular as possible. Use extension methods. Ensure that the percentage and the absolute values are within 0.1% of the margin (configurable, suppliable as an argument to the functions) as I use double precision and things rarely are 100% accurate, for DiscountAbsolute, DiscountRelative, GrossProfit%, GrossProfitAbsolute, VatPercentage, VatAbsolute (divide them into maybe a percentage consistency rule?). Also make sure that the quantities make sense; also write a CaltulateTotalUnitQuantity (it is internal) function that takes the object and returns it, also call it during the validation phase as an additional rule and check if it matches. Please comment all validation rules and why they exist; this logic will be shared with both the frontend and the backend. Also: write another validator that validates an invoice header given the List<Purchase> and the InvoiceHeader and returns the reason as again (bool ValidationStatus, string Error) which aggregates from again calls to ValidateDetailed that you have to write for the header, making sure things add up, the discounts add up. Be terse in code, but not in comments. Better to have them somehow numbered, I think.